#!/bin/ash

# =============================================================================
# Find'N'Run - find and run apps very quickly
  Version=1.10.4.2-gawk
# March-May 2015 by SFR and L18L; gawk fork by step
# GNU GPL applies
# http://www.murga-linux.com/puppy/viewtopic.php?t=98330
# Req.: Gtkdialog >= 0.8.3, gawk
# https://github.com/step-/find-n-run.git
# =============================================================================

export TEXTDOMAIN=find_n_run
export OUTPUT_CHARSET=UTF-8

APP_TITLE="$(gettext "Find'N'Run")-${Version}"
ABOUT="$(awk 'NR>3 && NR<9 {print substr($0,2)}' "$0")"

DESKTOP_FILES_DIRS="$XDG_DATA_HOME/applications /usr/local/share/applications /usr/share/applications"
ICON_DIRS="$HOME/.icons $XDG_DATA_HOME/icons /usr/share/icons /usr/share/pixmaps /usr/share/midi-icons /usr/share/mini-icons"

CONFIG="${HOME}/.findnrunrc"

DEBUG= # unset to disable debug trace to stderr; set verbosity (integer) 1-3
trap 'rm -f "${TMPF:-/tmp/dummy}"*' INT QUIT TERM HUP EXIT
TMPF=`mktemp`
DATF="${TMPF}.dat" # database of .desktop file entries
AWKF="${TMPF}-build.awk" # builds (and queries) database
AWKQ="${TMPF}-query.awk" # queries database (faster)
HSTF="${TMPF}.sh"; >"${HSTF}" # combobox command line history
SEP=`echo -e "\b"` # field separator of packed values
ICONCACHE="${HOME}/.icons" # location of icon cache files (in $CONFIG).

# -----------------------------------------------------------------------------

#LANG=de_DE.UTF-8 # just for demo
LR=${LANG%.*} #ex:pt_BR
L=${LANG%_*}  #ex:pt

# -----------------------------------------------------------------------------

# Unexport these variables before running the selected command.
UNEXPORT="unset GUI_ABOUT varENTRY varLIST varCMD varCOMMENT varOPEN varICONS TEXTDOMAIN OUTPUT_CHARSET"

# Defaults
defOPEN=false
export varICONS=false

# Read / supplement $CONFIG.
touch "${CONFIG}" && . "${CONFIG}" # must exist even if empty
# Add missing defaults.
awk '/^ICONCACHE=/{f=1}END{if(!f)print "ICONCACHE='"${ICONCACHE}"'">ARGV[1]}' "${CONFIG}"

# Values that depend on defaults.
ICONSTEM="${ICONCACHE}/findnrun-" # prefix to worked-around icons.

# =============================================================================

which gtkdialog4 >/dev/null 2>&1 && GTKDIALOG=gtkdialog4 || GTKDIALOG=gtkdialog

# -----------------------------------------------------------------------------

export GUI_ABOUT='
<window title="'${APP_TITLE}'" icon-name="edit-find" window-position="2">
  <vbox>
    <frame>
      <text justify="2" selectable="true" can-focus="false">
        <label>"'${ABOUT}'"</label>
      </text>
    </frame>
    <hbox homogeneous="true">
      <button ok>
        <action>closewindow:GUI_ABOUT</action>
      </button>
    </hbox>
  </vbox>
  <variable>GUI_ABOUT</variable>
</window>'

# -----------------------------------------------------------------------------

# Set LOCS to the glob that lists valid .desktop file locations.
# Do this in the main shell after having processed script option.
for i in ${DESKTOP_FILES_DIRS}; do
  set -- "$i"/*.desktop
  if [ "$1" != "${1%/*.desktop}/*.desktop" ]; then
    x=${1%% }; x=${x%/*}; LOCS="${LOCS}${LOCS+ }$x/*.desktop"
  else
    : # LOCi is empty or non-existent
  fi
done

# Prepare database builder gawk script
# Usage: gawk -f "scriptpath" [-v GREP="string"] [-v ALL_ICONS=true] files
[ -x /bin/dash ] && SH=/bin/dash || SH=/bin/ash
> "${AWKF}" echo '
BEGIN {
  if("'${DEBUG}'") print "\nSTARTING AWK builder, ALL_ICONS="ALL_ICONS >"/dev/stderr"
  RS="^~cannot~match~me~" # enable slurp read mode.
  # Choose a shell for ongoing command execution - see icon_workaround().
  sh = "'${SH}'" # not used as a coprocess
  ICONSTEM = "'"${ICONSTEM}"'" # prefix to worked-around icons.
  if("'${DEBUG}'") print "ICONSTEM="ICONSTEM >"/dev/stderr"
}
{
  # Slurp NFILES .desktop files.
  file[++NFILES]=";"FILENAME"\n"$0
  FILENAME="-in-section-END-"
}
END {
  # Is the icon work-around enabled and up-to-date?
  if(ICONUPDATED = is_icon_workaround_uptodate()) {
    # Speed up icon_workaround() by reading the icon index file.
    read_icon_index() # creates ICONINDEX map
  }
  # Decode .desktop files.
  if("'${DEBUG}'") print "awk decoding",NFILES,"files..." > "/dev/stderr"
  for(i=1; i<=NFILES; i++) {
    fil=file[i]
    name=exec=icnpath=icnname=icnext=comment=""
    match(fil, /^;([^\n]+)/, m); filename=m[1]
    match(fil, /\nName=([^\n]+)/, m); name=m[1]
    if(match(fil, /\nName\[('"${LR:-@}|${L:-@}"')\]=([^\n]+)/, m)) name=m[2]
    if(!name) continue # trap bogus .desktop files
    match(fil, /\nExec=([^\n]+)/, m); exec=m[1]
    if(!exec) continue # trap bogus .desktop files
    match(fil, /\nIcon=([^\n]*\/)?([^\n.]+)([.][^\n]*)?/, m)
    icnpath=m[1]; icnname=m[2]; icnext=substr(m[3],2)
    match(fil, /\nComment=([^\n]+)/, m); comment=m[1]
    if(match(fil, /\nComment\[('"${LR:-@}|${L:-@}"')\]=([^\n]+)/, m)) comment=m[2]
    # narrow matches by GREP pattern and store for sorting step
    if(GREP && index(tolower(name), GREP) || !GREP) {
      key[k] = k = tolower(name) # case-indepedent sort
      if(ALL_ICONS == "true") icon_workaround(sh)
      out[k] = format_item()
    }
  }
  # Sort by name and print.
  nkey = asort(key) # Note: asort is a GNU awk (gawk) extension.
  for(i=1; i<=nkey; i++) {
    print substr(out[key[i]], 1, 510)
    # 510 works around gtkdialog tree widget buffer overflow limit
  }
  # Remember if we performed a complete icon work-around.
  mark_icon_workaround_uptodate()
  # Close shell.
  print "exit" | sh
  close(sh)
  if("'${DEBUG}'") print "ENDING AWK" >"/dev/stderr"
}

# Format tree widget item - columns: icon, name, all-packed-values.
# Note: assert data does not include characters "|" and $SEP.
function format_item(   ic,cols) {
  ic = format_icon_cell()
  cols = sprintf("%s||%s|%s", \
    ic, name, \
    sprintf("%s'${SEP}'%s'${SEP}'%s'${SEP}'%s", filename,name,exec,comment))
    # tree widget exports all packed values as a single column
  return(cols)
}

# Format tree row icon cell.
# Use within <input icon-column="0"> or <stock-column="0">
# Note: tree widget does not support icons with paths anyway.
function format_icon_cell( ) {
  return(icnpath ? icnpath icnname "." icnext : icnname)
}

# Workaround for gtkdialog tree widget not displaying icons with path.
function icon_workaround(sh,    a,c,IFP,ifp,x,lnk,ext) {
  # Supposedly, IFP is the icon full path (it is used as the icon index key).
  IFP = icnpath icnname (icnext ?".":"") icnext
  if("" == IFP) return
  # If the work-around is not up-to-date run sh/finÄ‘/ln to create icon links.
  if(!ICONUPDATED) {
    #printf "L" > "/dev/stderr"
    ifp = IFP
    c = ""
    if(-1 == getline < ifp) { # file ifp does not exist
      # This could happen because .desktop file sets Icon=name-only (valid), but
      # we cannot trust gtkdialog to show icons by name only, so get fullpath.
      c = "2>/dev/null find -L '${ICON_DIRS}' " \
        " -type f -name \""icnname".*\" ! -path \"*/.*/*\" -print0 -quit"
        # ! -path "*/.*/*" excludes all matches within any hidden dir, neat!
        # -print0 ensures match string does not include \n character
        # -quit exits after first match, if any; GNU awk (gawk) extension.
      # Read found path into ifp, which stays == "" if nothing found.
      ifp=""; c | getline ifp; close(c)
      # Note that ifp is null-terminated. See \x00 below.
    } else { # file ifp exists
      close(ifp)
    }
    if("" != ifp) {
      sub(/\x00/,"",ifp)
    } else {
      print filename": Icon=" icnpath icnname "." icnext, "Not found." >"/dev/stderr"
      return
    }
    # gtkdialog tree can definitely display icon paths /usr/share/pixmaps/*
    # so try symlinking to target ifp
    x = split(ifp, a, /\//)
    lnk = a[x] # link name lnk <- icon-name[.ext] (no path)
    ext = (x = split(lnk, a, /\./)) ?"."a[x] :"" # ".ext" if any
    if(ext) x-- # forget ext from split link name
    # implode link name while replacing all dots with underscores
    lnk = ""; for(c=1; c<=x; c++) lnk = lnk "_" a[c]; lnk = substr(lnk, 2)
    # Symlink the icon.
    print "2>/dev/null ln -s \""ifp"\" \"" ICONSTEM lnk ext "\"" | sh
    # Progressively build the icon index file.
    printf "%s\x00%s\x00%s\x00%s\n", IFP, ifp, lnk, ext >> (ICONSTEM".index")
  } else {
    #printf "I" > "/dev/stderr"
    # The work-around is up-to-date so use ICONINDEX map to speed things up
    split(ICONINDEX[IFP], a, "\x00")
    lnk = a[3]
  }

  icnpath = "" # this tells format_item() to use icnname only
  icnname = "findnrun-" lnk # no ext
  # gtkdialog is very finicky: icon name must not include dots nor extension
  # but the link name must include an extension!
}

# Is the icon work-around enabled and up-to-date? - icon_workaround() helper.
function is_icon_workaround_uptodate(   uptodate,x) {
  if(uptodate = ("true" == ALL_ICONS)) {
    if(uptodate = (-1 != (getline < (x = ICONSTEM".uptodate"))))
      close(x)
  }
  if("'${DEBUG}'") print "is_icon_workaround_uptodate="uptodate > "/dev/stderr"
  return(uptodate)
}

# Read the index file - icon_workaround() helper
function read_icon_index(   a,b,data,i,x) {
  if("'${DEBUG}'") print "in read_icon_index" >"/dev/stderr"
  if(1 == (getline data < (x = ICONSTEM".index"))) {
    close(x)
    na = split(data, a, /\n/) # we slurped the index file
    for(i=1; i<=na; i++) {
      split(a[i], b, "\x00") # index record fields: IFP ifp lnk ext
      ICONINDEX[b[1]] = a[i]
    }
  }
}

# If the icon work-around is enabled, mark whether it is up-to-date.
function mark_icon_workaround_uptodate( ) {
  if("true" == ALL_ICONS) {
    print "" > (ICONSTEM".uptodate")
    if("'${DEBUG}'") print "\nmark_icon_workaround created", ICONSTEM".uptodate" > "/dev/stderr"
  }
}
'

# Prepare database query gawk script (a simplified version of the first script).
# Usage: gawk -f "scriptpath" [-v GREP="string"] ${DATF}
> "${AWKQ}" echo '
BEGIN {
  if("'${DEBUG}'">2) print "\nSTARTING AWK querier, GREP="GREP >"/dev/stderr"
  FS="|"
}
{
  # split out the last field of the record that format_item() printed ($AWKF)
  split($(NF), a, /'"${SEP}"'/) # a <- {filename, name, exec, comment}
  # narrow matches by GREP pattern
  if(GREP && index(tolower(a[2]), GREP) || !GREP) {
    print substr($0, 1, 510)
    # 510 works around gtkdialog tree widget buffer overflow limit
  }
}
END {
  if("'${DEBUG}'">2) print "ENDING AWK" >"/dev/stderr"
}
'

# Build database of .desktop file entries.
gawk -v ALL_ICONS=${varICONS} -f "${AWKF}" ${LOCS} > "${DATF}"

$GTKDIALOG -s >/dev/null <<EOF
<window title="${APP_TITLE}" icon-name="edit-find" window-position="2"  height-request="278" width-request="460">
  <vbox>    
    <hbox>
      <entry secondary-icon-stock="gtk-close" tooltip-text="$(gettext "Press ENTER to select")">
        <default>$(gettext "Type some letters to narrow the list")</default>
        <variable>varENTRY</variable>
        <action>refresh:varLIST</action>
        <action signal="activate">grabfocus:varLIST</action>
        <action signal="secondary-icon-release">clear:varENTRY</action>
      </entry>
    </hbox>

    <tree enable-search="false" exported-column="2" column-visible="1|1|0" headers-visible="false" icon-column-name="gtk-apply" hscrollbar-policy="1" vscrollbar-policy="1" tooltip-text="$(gettext "Press ENTER or double-click to run the selected item")">
      <label>Icon|Name|PackedValues</label>
      <variable>varLIST</variable>
      <input icon-column="0">gawk -f "${AWKQ}" -v GREP="\${varENTRY}" -v ALL_ICONS=\${varICONS} ${DATF}</input>
      <action>IFS=${SEP}; set -- \${varLIST}; set -- \${3% \%*}; echo "\$@" >>"${HSTF}"; ${UNEXPORT}; eval "\$@" &</action>
      <action condition="active_is_false(varOPEN)">exit:EXIT</action>
      <action signal="changed">refresh:varCMD</action>
      <action signal="changed">clear:varCOMMENT</action>
      <action signal="changed">refresh:varCOMMENT</action>
      <action>clear:varENTRY</action>
      <action>grabfocus:varENTRY</action>
    </tree>

    <hbox space-fill="false" space-expand="false">
      <comboboxentry space-expand="true" space-fill="true" tooltip-text="$(gettext "Press the up-arrow key to grab the current command and move through the command history. You can modify the command. You can enter any shell command. History persists while the window is kept open. History is cleared on exit.")">
        <variable>varCMD</variable>
        <default>$(gettext "Press up-arrow key to grab command")</default>
        <input file>${HSTF}</input>
        <input>IFS=${SEP}; set -- \${varLIST}; set -- \${3% \%*}; echo "\$@"</input>
        <output file>${HSTF}</output>

        <action signal="activate" condition="command_is_true(echo \${varCMD:-true})">break:</action>
        <action signal="activate">set -- \${varCMD}; echo "\$@" >> "${HSTF}"; ${UNEXPORT}; eval "\$@" &</action>
        <action signal="activate" condition="active_is_false(varOPEN)">exit:EXIT</action>
        <action signal="activate">clear:varENTRY</action>
        <action signal="activate">grabfocus:varENTRY</action>
        <action signal="activate">refresh:varCMD</action>
      </comboboxentry>
      <button tooltip-text="$(gettext "Remove the selected command history entry")">
        <height>16</height>
        <input file icon="edit-clear"></input>
        <action>removeselected:varCMD</action>
        <action>save:varCMD</action>
        <action>refresh:varCMD</action>
      </button>
    </hbox>

    <entry sensitive="false" tooltip-text="$(gettext "Comment")">
      <variable>varCOMMENT</variable>
      <input>IFS=${SEP}; set -- \${varLIST}; echo \$4</input>
    </entry>

    <hbox space-fill="false" space-expand="false">
      <checkbox use-underline="true" tooltip-text="$(gettext "When this option is disabled, the window closes soon after executing a command. Enable this option to use the command history feature, or to avoid startup delays.")">
        <label>$(gettext "_Leave this window open")</label>
        <default>${defOPEN}</default>
        <variable>varOPEN</variable>
        <action>awk -v s=defOPEN=\${varOPEN} '/^defOPEN=/{\$0=s;f=1}{a[++n]=\$0}END{if(!f)a[++n]=s;++n;for(i=1;i!=n;i++)print a[i]>ARGV[1]}' '${CONFIG}'</action>
      </checkbox>
      <checkbox use-underline="true" tooltip-text="$(gettext "Display all available icons. Caching all icons may take some time; please be patient. Disabling this option clears the cache completely.")">
        <label>$(gettext "Show all _icons")</label>
        <default>${varICONS}</default>
        <variable>varICONS</variable>
        <action>awk -v s=varICONS=\${varICONS} '/^varICONS=/{\$0=s;f=1}{a[++n]=\$0}END{if(!f)a[++n]=s;++n;for(i=1;i!=n;i++)print a[i]>ARGV[1]}' '${CONFIG}'</action>
        <action>clear:varENTRY</action>
        ${DEBUG:+<action>ls /usr/share/pixmaps/findnrun-.uptodate ~/.icons/findnrun-.uptodate >&2; cat ~/.findnrunrc >&2</action>}
        <action condition="command_is_true([ -f '${ICONSTEM}.uptodate' -a true = \${varICONS} ] && echo true)">break:</action>
        ${DEBUG:+<action>if true echo >&2 in true rebuilding database...</action>}
        <action>if true gawk -v ALL_ICONS=\${varICONS} -f '${AWKF}' ${LOCS} > '${DATF}'</action>
        ${DEBUG:+<action>if true echo >&2 in true clear:varLIST</action>}
        <action>if true clear:varLIST</action>
        ${DEBUG:+<action>if true echo >&2 in true refresh:varLIST</action>}
        <action>if true refresh:varLIST</action>
        ${DEBUG:+<action>if false echo >&2 in false rm -f \{~/.icons\|/usr/share/pixmaps\}/findnrun-\*</action>}
        <action>if false rm -f '${ICONSTEM:-/tmp/dummy}'*</action>
        ${DEBUG:+<action>if false echo >&2 in false rebuilding database...</action>}
        <action>if false gawk -v ALL_ICONS=\${varICONS} -f '${AWKF}' ${LOCS} > '${DATF}'</action>
        ${DEBUG:+<action>if false echo >&2 in false clear:varLIST</action>}
        <action>if false clear:varLIST</action>
        ${DEBUG:+<action>if false echo >&2 in false refresh:varLIST</action>}
        <action>if false refresh:varLIST</action>
      </checkbox>
      <text space-fill="true" space-expand="true"><label>""</label></text>
      <button tooltip-text="$(gettext "About")">
        <height>16</height>
        <input file icon="gtk-about"></input>
        <action>launch:GUI_ABOUT</action>
      </button>
      <button tooltip-text="$(gettext "Exit")">
        <height>16</height>
        <input file icon="gtk-quit"></input>
        <action>exit:EXIT</action>
      </button>
    </hbox>

  </vbox>
  <action signal="key-press-event" condition="command_is_true([ \$KEY_SYM = Escape ] && echo true )">exit:EXIT</action>
  <action signal="delete-event">exit:abort</action>
</window>
EOF

###############################################################################

